<html lang="en" class="js-focus-visible" data-js-focus-visible="">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Generated Scenarios</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="shortcut icon" href="/static/assets/images/favicon.png">
    <style>
        /* Replace existing loader styles with new circular loader styles */
        .loader-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .percentage-loader {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .circular-loader {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
            animation: circleRotate 1.5s linear infinite;
        }

        .loader-bg,
        .loader-fg {
            fill: none;
            stroke-width: 10;
            cx: 50;
            cy: 50;
            r: 45;
        }

        .loader-bg {
            stroke: #ddd;
        }

        .loader-fg {
            stroke: #FF3D00;
            stroke-linecap: round;
            transform-origin: center;
            stroke-dasharray: 283;
            /* Ensure at least a small part of the circle is always visible */
            stroke-dashoffset: 252; /* Default to showing ~10% of the circle */
            transition: stroke-dashoffset 0.3s ease;
        }

        /* Ensure at least part of the circle is visible even at 0% */
        .loader-fg.visible-progress {
            stroke-dashoffset: 275; /* Show a small part of the circle even at 0% */
        }

        .loader-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            z-index: 20;
        }

        .loader {
            width: 175px;
            height: 80px;
            display: block;
            margin: auto;
            background-image: radial-gradient(circle 25px at 25px 25px, #FFF 100%, transparent 0), radial-gradient(circle 50px at 50px 50px, #FFF 100%, transparent 0), radial-gradient(circle 25px at 25px 25px, #FFF 100%, transparent 0), linear-gradient(#FFF 50px, transparent 0);
            background-size: 50px 50px, 100px 76px, 50px 50px, 120px 40px;
            background-position: 0px 30px, 37px 0px, 122px 30px, 25px 40px;
            background-repeat: no-repeat;
            position: relative;
            box-sizing: border-box;
        }

        /* Keep existing loader animations */
        .loader::after {
            content: '';
            left: 50%;
            bottom: 0;
            transform: translate(-50%, 0);
            position: absolute;
            border: 15px solid transparent;
            border-top-color: #FF3D00;
            box-sizing: border-box;
            animation: fadePush 1s linear infinite;
        }

        .loader::before {
            content: '';
            left: 50%;
            bottom: 30px;
            transform: translate(-50%, 0);
            position: absolute;
            width: 15px;
            height: 15px;
            background: #FF3D00;
            box-sizing: border-box;
            animation: fadePush 1s linear infinite;
        }

        @keyframes fadePush {
            0% {
                transform: translate(-50%, -15px);
                opacity: 0;
            }

            50% {
                transform: translate(-50%, 0px);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, 15px);
                opacity: 0;
            }
        }

        /* New styles for modern UI */
        body {
            background-color: #f8f9fa;
        }

        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 20 20px;
        }

        a {
            color: rgb(76, 171, 114);
            text-decoration: none;
            transition: all 0.3s ease !important;
        }

        a:hover {
            font-weight: 700;
            color: rgb(76, 171, 114);
        }

        .card {
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: none;
        }

        .form-label {
            font-weight: 500;
            color: #041E2B;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .form-label i {
            color: #61b984;
        }

        .form-control,
        .form-select {
            border-radius: 6px;
            border: 1px solid #ced4da;
            padding: 0.5rem 0.75rem;
        }

        .btn-primary {
            background-color: rgb(76, 171, 114);
            border: 1px solid rgb(76, 171, 114);
            padding: 8px 22px;
            border-radius: 6px;
            font-size: 14px;
            box-shadow: 0 14px 26px -12px rgba(76, 171, 114, 0.42), 0 4px 23px 0 rgba(0, 0, 0, 0.12), 0 8px 10px -5px rgba(76, 171, 114, 0.20);
        }

        .btn-secondary {
            background-color: transparent;
            border: 1px solid rgba(4, 30, 43, 0.5);
            color: rgb(4, 30, 43);
            padding: 8px 22px;
            font-size: 14px;

        }

        .btn {
            border-radius: 4px;
            font-weight: 400;
        }

        .btn-primary:hover,
        .btn-primary:focus {
            background-color: rgba(76, 171, 114, 0.1);
            border-color: rgb(76, 171, 114);
            box-shadow: none;
            color: rgb(76, 171, 114);
            font-weight: 400;
        }

        .btn-secondary:hover,
        .btn-secondary:focus {
            font-weight: 400;
            background-color: rgba(4, 30, 43, 0.1);
            border-color: rgba(4, 30, 43, 0.5);
            color: rgba(4, 30, 43, 1);
            box-shadow: 0 14px 26px -12px rgba(4, 30, 43, 0.2), 0 4px 23px 0 rgba(0, 0, 0, 0.12), 0 8px 10px -5px rgba(4, 30, 43, 0.2);
        }

        .btn:focus {
            box-shadow: none !important;
            font-weight: 400;
        }

        .form-control:focus,
        .form-select:focus {
            border-color: rgb(76, 171, 114);
            box-shadow: none;
        }

        div:has(input:focus)>.form-label,
        div:has(select:focus)>.form-label {
            color: rgb(76, 171, 114) !important;
        }

        h1 {
            text-align: center;
            color: #212529;
            margin-bottom: 1rem;
        }

        .subtitle {
            text-align: center;
            color: rgba(4, 30, 43, 0.5);
            margin-bottom: 0;
        }

        .help-text {
            text-align: center;
            margin-top: 2rem;
        }



        .header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            padding: 24px 0;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 24px;
        }

        .logo {
            margin-bottom: 12px;
        }

        .logo>img {
            max-height: 40px;
        }

        .center-content {
            max-width: calc(100% - 456px);
            flex: 1;
        }

        h1.main-title {
            font-size: 1.8rem;
            margin-bottom: 0;
            color: #041E2B;
        }

        .card-body {
            padding: 40px;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            color: #041E2B;
        }

        .form-text {
            color: rgba(4, 30, 43, 0.5);
            font-size: 13px;
        }

        ::placeholder {
            color: rgba(4, 30, 43, 0.5) !important;
        }

        .form-check-input:checked {
            background-color: rgb(76, 171, 114);
            border-color: rgb(76, 171, 114);
        }

        .form-check-input:focus {
            box-shadow: none;
        }

        .form-control,
        .form-select,
        .form-check-label {
            font-size: 14px;
        }

        .status-select {
            width: 100%;
            min-width: 120px;
            padding: 4px 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            background-color: white;
            color: #041E2B;
        }

        .status-select:focus {
            border-color: rgb(76, 171, 114);
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(76, 171, 114, 0.25);
        }

        .status-select option {
            padding: 8px;
        }

        .form-check {
            flex: 0 0 calc(25% - 12px);
            cursor: pointer;
        }

        .accordion-button {
            background-color: rgba(4, 30, 43, 0.03);
            border-color: rgba(4, 30, 43, 1);
            color: rgba(4, 30, 43, 1);
        }

        .accordion-button:not(.collapsed) {
            background-color: rgba(76, 171, 114, 0.1);
            border-color: rgb(76, 171, 114);
            color: rgb(76, 171, 114);
        }

        .accordion-button:not(.collapsed)::after {
            background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%234cab72'><path fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/></svg>");
            transform: rotate(-180deg);
        }

        .accordion-button:focus {
            box-shadow: 0 0 0 .25rem rgba(76, 171, 114, .25);
        }

        .table {
            font-size: 14px;
            color: rgba(4, 30, 43, 0.7);
        }

        .table-striped>tbody>tr:nth-of-type(odd)>* {
            color: rgba(4, 30, 43, 0.7);
            --bs-table-accent-bg: rgba(4, 30, 43, 0.05);
        }

        .table thead>tr>th {
            font-size: 15px;
            color: rgba(4, 30, 43, 1);
            text-transform: uppercase;
            background-color: rgba(4, 30, 43, 0.1);
        }

        @media (min-width: 768px) {
            .gap-md-0 {
                gap: 0 !important;
            }
        }

        @media (max-width: 767px) {
            .header {
                flex-direction: column;
                align-items: center;
            }

            .logo {
                margin-bottom: 1rem;
            }

            .center-content {
                text-align: center;
                max-width: 100%;
            }
        }

        @media (max-width: 576px) {
            .form-label i {
                font-size: 1.2rem;
            }

            .form-control,
            .form-select {
                font-size: 0.9rem;
            }

        }

        /* Style all button types to use the same green theme */
        .btn-success,
        .btn-info,
        .btn-warning,
        .btn-secondary {
            background-color: rgb(76, 171, 114);
            border: 1px solid rgb(76, 171, 114);
            padding: 8px 22px;
            border-radius: 6px;
            font-size: 14px;
            color: #fff;
            box-shadow: 0 14px 26px -12px rgba(76, 171, 114, 0.42), 0 4px 23px 0 rgba(0, 0, 0, 0.12), 0 8px 10px -5px rgba(76, 171, 114, 0.20);
        }

        .btn-success:hover,
        .btn-success:focus,
        .btn-info:hover,
        .btn-info:focus,
        .btn-warning:hover,
        .btn-warning:focus,
        .btn-secondary:hover,
        .btn-secondary:focus {
            background-color: rgba(76, 171, 114, 0.1);
            border-color: rgb(76, 171, 114);
            box-shadow: none;
            color: rgb(76, 171, 114);
            font-weight: 400;
        }

        /* Style for the "Generate New" button in header */
        .header .btn-primary {
            background-color: rgb(76, 171, 114);
            border: 1px solid rgb(76, 171, 114);
            padding: 8px 22px;
            border-radius: 6px;
            font-size: 14px;
            color: #fff;
            font-weight: 400;
            box-shadow: 0 14px 26px -12px rgba(76, 171, 114, 0.42), 0 4px 23px 0 rgba(0, 0, 0, 0.12), 0 8px 10px -5px rgba(76, 171, 114, 0.20);
        }

        .header .btn-primary:hover,
        .header .btn-primary:focus {
            background-color: rgba(76, 171, 114, 0.1);
            border-color: rgb(76, 171, 114);
            color: rgb(76, 171, 114);
            box-shadow: none;
            font-weight: 400;
        }

        /* Add spinning animation CSS */
        .spin {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Improved continuous rotation animation for the circular loader */
        @keyframes circleRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .circular-animate {
            animation: circleRotate 1.5s linear infinite;
        }

        /* Add a pulsating effect to make the loading indicator more noticeable */
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #FF3D00;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite, pulse 2s ease-in-out infinite;
        }

        /* Add a continuously rotating spinner ring */
        .spinner-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                #FF3D00 0deg, 
                rgba(255, 61, 0, 0.8) 90deg, 
                rgba(255, 61, 0, 0.6) 180deg,
                rgba(255, 61, 0, 0.4) 270deg,
                rgba(255, 61, 0, 0.1) 360deg
            );
            animation: spinnerRotate 1.5s linear infinite;
            z-index: 10;
        }

        @keyframes spinnerRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Make the progress circle semi-transparent to see the spinner behind it */
        .circular-loader {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
            position: relative;
            z-index: 5;
        }
    </style>
</head>

<body data-new-gr-c-s-check-loaded="14.1104.0" data-gr-ext-installed="">
    <div class="container">
        <div class="header flex-column align-items-center gap-4 gap-md-0">
            <div class="logo">
                <img src="/static/assets/images/ev--logo.svg" alt="">
            </div>
            <div class="d-flex justify-content-between w-100">
                <h1 class="main-title">AI-Powered Generated Scenarios</h1>
                <a href="/" class="btn btn-primary">Generate New</a>
            </div>
        </div>

        <div class="accordion" id="testCasesList"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const urlParams = new URLSearchParams(window.location.search);
            const filesParam = urlParams.get('files');
            const urlKey = urlParams.get('key');

            // Check for both required parameters
            if (!filesParam || !urlKey) {
                document.getElementById('testCasesList').innerHTML =
                    `<div class="alert alert-danger">${!filesParam ? 'No files specified in URL.' : 'No URL key found. Please ensure you have a valid URL.'}</div>`;
                return;
            }

            // Store URL key in a global variable for use across functions
            window.testCaseUrlKey = urlKey;

            try {
                window.files = JSON.parse(decodeURIComponent(filesParam));
            } catch (error) {
                document.getElementById('testCasesList').innerHTML = '<div class="alert alert-danger">Invalid file data in URL.</div>';
                return;
            }

            const testCasesList = document.getElementById('testCasesList');

            // Global state to track loading
            window.loadingState = {
                isGenerating: true,
                retryCount: 0,
                maxRetries: 60, // 2 minutes (2s * 60)
                loadedFiles: new Set(),
                pollInterval: null,  // Add this to track the polling interval
                directVerificationAttempted: false // Track if we've tried direct verification
            };

            // Initialize UI
            Object.entries(window.files).forEach(([itemId, fileSet], index) => {
                const accordionItem = document.createElement('div');
                accordionItem.className = 'accordion-item';
                accordionItem.innerHTML = `
                <h2 class="accordion-header" id="heading${itemId}">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" 
                            data-bs-target="#collapse${itemId}" aria-expanded="false" aria-controls="collapse${itemId}">
                        Test Cases for ${itemId}
                        <span id="status-${itemId}" class="ms-2">Generating test cases...</span>
                    </button>
                </h2>
                <div id="collapse${itemId}" class="accordion-collapse collapse" aria-labelledby="heading${itemId}" data-bs-parent="#testCasesList">
                    <div class="accordion-body">
                        <div class="mb-3">
                            <div class="btn-group d-flex gap-2" id="buttons-${itemId}">
                                <a href="/api/download/${fileSet.txt}?filename=test_${itemId}.txt" class="btn btn-primary" id="txt-${itemId}">Download TXT</a>
                                <a href="/api/download/${fileSet.excel}?filename=test_${itemId}.xlsx" class="btn btn-success" id="excel-${itemId}">Download Excel</a>
                                <button class="btn btn-warning" id="copy-table-${itemId}" onclick="copyTestCaseTable('${itemId}')">Copy Table</button>
                                <button class="btn btn-secondary" id="copy-${itemId}" onclick="copyTestCaseUrl('${itemId}')">Copy URL</button>
                                <button class="btn btn-primary" id="share-${itemId}" onclick="shareTestCase('${itemId}')">Share URL</button>
                            </div>
                        </div>
                        <div id="testCaseTable${itemId}" class="table-container">
                            <div class="text-center">Loading test cases...</div>
                        </div>
                    </div>
                </div>
            `;
                testCasesList.appendChild(accordionItem);
                console.log(`Created accordion item for ${itemId}`);

                // Automatically load test cases
                loadTestCases(itemId);
            });

            // Start with direct file verification immediately
            verifyFiles();

            // Also check generation status via API
            checkGenerationStatus();

            // Apply saved status values after test cases are loaded
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        const statusSelects = document.querySelectorAll('.status-select');
                        if (statusSelects.length > 0) {
                            console.log('Status selects found, applying saved values');
                            applyStatusValues();
                            updateDownloadLinks();
                        }
                    }
                });
            });
            
            // Start observing the document for added nodes
            observer.observe(document.body, { childList: true, subtree: true });

            // Fallback 1: After 2 seconds, try to show content again
            setTimeout(function () {
                if (window.loadingState.isGenerating) {
                    console.log("First fallback timeout - attempting to show content");
                    verifyFiles();
                }
                
                // Try to apply status values again after a delay
                applyStatusValues();
            }, 2000); // 2 seconds

            // Fallback 2: After 5 seconds, enable download buttons directly
            setTimeout(function () {
                console.log("Second fallback timeout - enabling download buttons directly");
                enableDownloadButtons();
                
                // Try to apply status values once more
                applyStatusValues();
            }, 5000); // 5 seconds
            
            // Start polling for status updates from shared views
            setupStatusPolling();
        });

        // Function to stop polling
        function stopPolling() {
            console.log('Stopping polling');
            if (window.loadingState.pollInterval) {
                clearTimeout(window.loadingState.pollInterval);
                window.loadingState.pollInterval = null;
            }
            window.loadingState.isGenerating = false;
        }

        async function checkGenerationStatus() {
            // If we're no longer generating, stop checking
            if (!window.loadingState.isGenerating) {
                console.log("Generation status check stopped - no longer generating");
                return;
            }

            if (window.loadingState.retryCount >= window.loadingState.maxRetries) {
                showError('Generation timeout, but you can still access available files.');
                enableDownloadButtons();
                return;
            }

            try {
                // Get item IDs from the files object
                const itemIds = Object.keys(window.files).join(',');
                const response = await fetch(`/api/generation-status?items=${itemIds}`);
                if (!response.ok) throw new Error('Failed to check generation status');

                const status = await response.json();

                // Update progress for each item
                Object.entries(window.files).forEach(([itemId]) => {
                    const statusSpan = document.getElementById(`status-${itemId}`);
                    // Make sure progress is a valid number, defaulting to '' (no percentage) if invalid
                    let progress = status.progress_percentage;
                    
                    // Check if progress is a valid number and between 0-100
                    if (typeof progress !== 'number' || isNaN(progress) || progress < 0 || progress > 100) {
                        // Don't show percentage if invalid
                        statusSpan.innerHTML = 'Generating test cases...';
                    } else {
                        // Only show percentage if it's a valid number
                        progress = Math.round(progress);
                        // Calculate offset ensuring at least 10% is visible at 0%
                        const dashOffset = progress === 0 ? 252 : progress === 100 ? 0 : 283 - (progress / 100) * 283;
                        statusSpan.innerHTML = `Generating... ${progress}% complete`;
                    }
                });

                // Check if generation is complete and files are ready
                if (!status.is_generating && status.files_ready) {
                    await verifyFiles();
                    return;
                }

                // Also check directly for files every few retries
                if (window.loadingState.retryCount % 3 === 0) {
                    console.log("Periodically checking for files directly");
                    await verifyFiles();
                }

                // If still generating or files not ready, continue checking
                window.loadingState.retryCount++;
                window.loadingState.pollInterval = setTimeout(checkGenerationStatus, 2000);
            } catch (error) {
                console.error('Error checking generation status:', error);
                window.loadingState.retryCount++;
                window.loadingState.pollInterval = setTimeout(checkGenerationStatus, 5000);

                // Try direct verification on error
                if (!window.loadingState.directVerificationAttempted) {
                    window.loadingState.directVerificationAttempted = true;
                    console.log("Status API error - trying direct verification");
                    await verifyFiles();
                }
            }
        }

        async function verifyFiles() {
            console.log('Verifying files directly:', window.files);

            // Reset retry count to avoid premature timeout
            window.loadingState.retryCount = 0;

            let anyFileVerified = false;

            // Try to verify and load content for each file
            const verificationPromises = Object.entries(window.files).map(async ([itemId, fileSet]) => {
                try {
                    console.log(`Checking file content for ${itemId}`);

                    // Check Excel file
                    const excelResponse = await fetch(`/api/content/${fileSet.excel}`);

                    // Check TXT file
                    const txtResponse = await fetch(`/api/content/${fileSet.txt}`);

                    // Enable buttons for this item if either file is available
                    // In the verifyFiles function, update the button display code:
                    if (excelResponse.ok || txtResponse.ok) {
                        anyFileVerified = true;
                        console.log(`File verified for ${itemId} - Excel: ${excelResponse.ok}, TXT: ${txtResponse.ok}`);

                        const buttons = document.getElementById(`buttons-${itemId}`);
                        const txtBtn = document.getElementById(`txt-${itemId}`);
                        const excelBtn = document.getElementById(`excel-${itemId}`);
                        const copyBtn = document.getElementById(`copy-${itemId}`);
                        const shareBtn = document.getElementById(`share-${itemId}`);
                        const statusSpan = document.getElementById(`status-${itemId}`);

                        // Show all buttons container
                        if (buttons) buttons.style.display = 'flex';

                        // Show individual buttons based on file availability
                        if (txtResponse.ok && txtBtn) txtBtn.style.display = 'inline-block';
                        if (excelResponse.ok && excelBtn) excelBtn.style.display = 'inline-block';
                        if (excelResponse.ok && copyBtn) copyBtn.style.display = 'inline-block';
                        if (excelResponse.ok && shareBtn) shareBtn.style.display = 'inline-block';

                        if (statusSpan) statusSpan.innerHTML = '✓ Complete';

                        // Automatically load test cases if Excel file is available
                        if (excelResponse.ok) {
                            loadTestCases(itemId);
                        }
                    }
                } catch (error) {
                    console.error(`Error verifying files for ${itemId}:`, error);
                }
            });

            // Wait for all verifications to complete
            await Promise.all(verificationPromises);

            // Show content if any file was verified
            if (anyFileVerified) {
                console.log("At least one file was verified successfully, stopping polling");
                window.loadingState.isGenerating = false;
                stopPolling();
            }

            // As a final fallback, always enable download buttons after verification attempts
            setTimeout(enableDownloadButtons, 500);
        }

        function showContent() {
            console.log('Showing content for files:', window.files);

            // First, set the global state to indicate generation is complete
            window.loadingState.isGenerating = false;

            // Process each file entry
            Object.entries(window.files).forEach(([itemId, fileSet]) => {
                try {
                    // Get the necessary elements by ID
                    const statusSpan = document.getElementById(`status-${itemId}`);
                    const buttons = document.getElementById(`buttons-${itemId}`);
                    const txtBtn = document.getElementById(`txt-${itemId}`);
                    const excelBtn = document.getElementById(`excel-${itemId}`);

                    // Update status message
                    if (statusSpan) statusSpan.innerHTML = '✓ Complete';

                    // Update header status
                    updateHeaderStatus(itemId);

                    // Show the action buttons if they exist
                    if (buttons) buttons.style.display = 'flex';
                    if (txtBtn) txtBtn.style.display = 'inline-block';
                    if (excelBtn) excelBtn.style.display = 'inline-block';

                    console.log(`Showing buttons for ${itemId}`);

                    // Automatically load test cases
                    loadTestCases(itemId);

                    // Try to expand the accordion
                    const accordionButton = document.querySelector(`button[data-bs-target="#collapse${itemId}"]`);
                    if (accordionButton && accordionButton.classList.contains('collapsed')) {
                        try {
                            accordionButton.click();
                            console.log(`Expanded accordion for ${itemId}`);
                        } catch (err) {
                            console.warn(`Could not expand accordion for ${itemId}:`, err);
                        }
                    }
                } catch (error) {
                    console.error(`Error updating UI for ${itemId}:`, error);
                }
            });
        }

        function showError(message) {
            Object.entries(window.files).forEach(([itemId]) => {
                const statusSpan = document.getElementById(`status-${itemId}`);
                statusSpan.innerHTML = '❌ Error';

                // Add error message but don't completely replace container content
                const container = document.getElementById(`testCaseTable${itemId}`);
                if (container.innerHTML.indexOf('alert-danger') === -1) {
                    container.innerHTML = `<div class="alert alert-danger">${message}</div>` + container.innerHTML;
                }
            });
            window.loadingState.isGenerating = false;
        }

        // Modified function to load test cases without debug controls
        async function loadTestCases(itemId) {
            console.log(`Loading test cases for ${itemId}`);

            // Get container and verify files exist
            const container = document.getElementById(`testCaseTable${itemId}`);
            if (!container) {
                alert('Error: Could not find container for test cases');
                return;
            }

            try {
                // Fetch test cases using the correct file path with cache busting
                const timestamp = Date.now();
                const response = await fetch(`/api/content/${window.files[itemId].excel}?t=${timestamp}`, {
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    },
                    cache: 'no-store'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }

                const data = await response.json();

                // Handle error in the response
                if (data.error) {
                    throw new Error(data.error);
                }

                // Store test cases for sharing
                if (!window.testCases) window.testCases = {};
                window.testCases[itemId] = data.content;

                // Display content based on type
                if (Array.isArray(data.content)) {
                    if (data.content.length > 0) {
                        try {
                            const table = createTestCaseTable(data.content);
                            container.innerHTML = '';
                            container.appendChild(table);
                            
                            // Apply any saved status values immediately after table is created
                            console.log(`Table created for ${itemId}, applying saved status values...`);
                            setTimeout(() => {
                                applyStatusValues();
                                updateDownloadLinks();
                            }, 50);
                            
                        } catch (tableError) {
                            console.error('Error creating table:', tableError);
                            container.innerHTML = `
                        <div class="alert alert-warning">
                            <p>Error displaying test case table. Showing raw data instead.</p>
                        </div>
                        <pre class="bg-light p-3">${JSON.stringify(data.content, null, 2)}</pre>
                    `;
                        }
                    } else {
                        container.innerHTML = '<div class="alert alert-info">No test cases found in the file.</div>';
                    }
                }
            } catch (error) {
                console.error('Error loading test cases:', error);
                container.innerHTML = `<div class="alert alert-danger">Error loading test cases: ${error.message}</div>`;
            }
        }

        // Extract test case ID from row
        function extractTestCaseId(row, index) {
            // Priority 1: Use title as the ID since the user has unique titles
            if (row['Title']) {
                console.log(`Using Title as ID: ${row['Title']}`);
                return row['Title'];
            }
            
            // Priority 2: Use existing Test Case ID field
            if (row['Test Case ID']) {
                console.log(`Using Test Case ID field: ${row['Test Case ID']}`);
                return row['Test Case ID'];
            }
            
            // Priority 3: Use test_case_id field
            if (row['test_case_id']) {
                console.log(`Using test_case_id field: ${row['test_case_id']}`);
                return row['test_case_id'];
            }
            
            // Priority 4: Fallback to generated ID based on index
            console.log(`Using generated ID for row ${index}: TC_KAN-1_${index + 2}`);
            return `TC_KAN-1_${index + 2}`;
        }

        function createTestCaseTable(content) {
            try {
                const table = document.createElement('table');
                table.className = 'table table-striped';
                table.setAttribute('data-loaded', 'true');

                // Log the first row of data to see structure
                if (content && content.length > 0) {
                    console.log("Sample test case data:", content[0]);
                }

                // Add Status to desired order
                const desiredOrder = ['Title', 'Scenario', 'Steps', 'Expected Result', 'Status'];

                // Create table header
                const thead = document.createElement('thead');
                thead.innerHTML = `
            <tr>
                ${desiredOrder.map(header => `<th>${header}</th>`).join('')}
            </tr>
        `;
                table.appendChild(thead);

                // Create table body
                const tbody = document.createElement('tbody');

                // Process each row
                content.forEach((row, index) => {
                    const tr = document.createElement('tr');

                    desiredOrder.forEach(header => {
                        const td = document.createElement('td');
                        if (header === 'Status') {
                            // Get test case ID
                            let testCaseId = extractTestCaseId(row, index);
                            console.log(`Using test case ID: ${testCaseId} for row ${index}`);

                            // Create status dropdown
                            const currentStatus = row.Status || '';
                            td.innerHTML = `
                        <select class="form-select status-select" 
                                data-original-value="${currentStatus}" 
                                data-test-case-id="${testCaseId}">
                            <option value="" ${!currentStatus ? 'selected' : ''}>Select Status</option>
                            <option value="Pass" ${currentStatus === 'Pass' ? 'selected' : ''}>Pass</option>
                            <option value="Fail" ${currentStatus === 'Fail' ? 'selected' : ''}>Fail</option>
                            <option value="Blocked" ${currentStatus === 'Blocked' ? 'selected' : ''}>Blocked</option>
                            <option value="Not Tested" ${currentStatus === 'Not Tested' ? 'selected' : ''}>Not Tested</option>
                        </select>
                    `;
                        } else if (header === 'Steps') {
                            // Try multiple fields for steps data
                            const value = row[header] || row['Test Steps'] || row['steps'] || [];
                            
                            if (value === null || value === undefined) {
                                td.innerHTML = '<em>Not provided</em>';
                            } else if (Array.isArray(value)) {
                                const listHtml = value.map((step, idx) =>
                                    `<div>${idx + 1}. ${step}</div>`
                                ).join('');
                                td.innerHTML = listHtml || '<em>No steps provided</em>';
                            } else if (typeof value === 'object') {
                                try {
                                    td.innerHTML = JSON.stringify(value);
                                } catch (e) {
                                    td.innerHTML = '<em>Complex value</em>';
                                }
                            } else {
                                td.innerHTML = String(value).replace(/\n/g, '<br>') || '<em>No steps provided</em>';
                            }
                        } else {
                            const value = row[header];
                            if (value === null || value === undefined) {
                                td.innerHTML = '<em>Not provided</em>';
                            } else if (Array.isArray(value)) {
                                const listHtml = value.map((step, idx) =>
                                    `<div>${idx + 1}. ${step}</div>`
                                ).join('');
                                td.innerHTML = listHtml;
                            } else if (typeof value === 'object') {
                                try {
                                    td.innerHTML = JSON.stringify(value);
                                } catch (e) {
                                    td.innerHTML = '<em>Complex value</em>';
                                }
                            } else {
                                td.innerHTML = String(value).replace(/\n/g, '<br>');
                            }
                        }
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });

                table.appendChild(tbody);
                
                return table;
            } catch (error) {
                console.error('Error creating test case table:', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'alert alert-danger';
                errorDiv.textContent = 'Error creating table: ' + error.message;
                return errorDiv;
            }
        }

        // Function to directly enable download buttons, regardless of other status
        function enableDownloadButtons() {
            console.log('Enabling all download buttons directly');
            Object.entries(window.files).forEach(([itemId, fileSet]) => {
                const buttons = document.getElementById(`buttons-${itemId}`);
                const txtBtn = document.getElementById(`txt-${itemId}`);
                const excelBtn = document.getElementById(`excel-${itemId}`);
                const copyBtn = document.getElementById(`copy-${itemId}`);
                const shareBtn = document.getElementById(`share-${itemId}`);
                const statusSpan = document.getElementById(`status-${itemId}`);

                if (buttons) buttons.style.display = 'flex';
                if (txtBtn) txtBtn.style.display = 'inline-block';
                if (excelBtn) excelBtn.style.display = 'inline-block';
                if (copyBtn) copyBtn.style.display = 'inline-block';
                if (shareBtn) shareBtn.style.display = 'inline-block';
                if (statusSpan) statusSpan.innerHTML = '✓ Files Ready';
            });
        }

        // Update header status after content is loaded
        function updateHeaderStatus(itemId) {
            const headerStatus = document.querySelector(`#heading${itemId} button span`);
            if (headerStatus) {
                headerStatus.innerHTML = '✓ Complete';
            }
        }
    </script>

    <script>
        // Improved localStorage persistence for status values
        function saveStatusesToLocalStorage() {
            const statusValues = {};
            const statusSelects = document.querySelectorAll('.status-select');
            
            statusSelects.forEach(select => {
                const testCaseId = select.getAttribute('data-test-case-id');
                const status = select.value;
                if (testCaseId && status) {
                    statusValues[testCaseId] = status;
                }
            });
            
            const urlKey = window.testCaseUrlKey;
            if (urlKey) {
                const storageKey = `status_values_${urlKey}`;
                console.log(`Saving statuses to localStorage with key "${storageKey}":`, statusValues);
                localStorage.setItem(storageKey, JSON.stringify(statusValues));
            }
        }

        // Apply saved status values to the UI as soon as possible
        function applyStatusValues() {
            const urlKey = window.testCaseUrlKey;
            if (!urlKey) {
                console.warn('Cannot apply status values: No URL key found');
                return;
            }
            
            try {
                const storageKey = `status_values_${urlKey}`;
                const saved = localStorage.getItem(storageKey);
                console.log(`Checking localStorage for key "${storageKey}":`, saved);
                
                if (saved) {
                    const statusValues = JSON.parse(saved);
                    console.log('Loaded statuses from localStorage:', statusValues);
                    
                    // Apply to all select elements
                    const statusSelects = document.querySelectorAll('.status-select');
                    console.log(`Found ${statusSelects.length} status select elements to update`);
                    
                    let appliedCount = 0;
                    statusSelects.forEach(select => {
                        const testCaseId = select.getAttribute('data-test-case-id');
                        if (testCaseId && statusValues[testCaseId]) {
                            select.value = statusValues[testCaseId];
                            select.setAttribute('data-original-value', statusValues[testCaseId]);
                            appliedCount++;
                        }
                    });
                    
                    console.log(`Applied ${appliedCount} saved status values`);
                    
                    // Update download links with saved status values
                    updateDownloadLinks();
                    return true;
                } else {
                    console.log('No saved status values found in localStorage');
                }
            } catch (e) {
                console.error('Error applying saved statuses:', e);
            }
            return false;
        }

        // Direct status collection from DOM - improved to always get latest values
        function collectStatusValues() {
            const statusValues = {};
            const statusSelects = document.querySelectorAll('.status-select');
            
            statusSelects.forEach(select => {
                const testCaseId = select.getAttribute('data-test-case-id');
                const status = select.value;
                if (testCaseId && status) {
                    statusValues[testCaseId] = status;
                }
            });
            
            console.log('Collected status values:', statusValues);
            return statusValues;
        }

        // Improved download links update function with forced refresh
        function updateDownloadLinks() {
            // Get fresh status values directly from DOM elements
            const statusSelects = document.querySelectorAll('.status-select');
            const freshStatusValues = {};
            
            statusSelects.forEach(select => {
                const testCaseId = select.getAttribute('data-test-case-id');
                const status = select.value;
                if (testCaseId && status) {
                    freshStatusValues[testCaseId] = status;
                    console.log(`Update Download Links - Fresh status for ${testCaseId}: ${status}`);
                }
            });
            
            const statusParam = encodeURIComponent(JSON.stringify(freshStatusValues));
            
            // Always update download links, even with empty status values
            console.log('Updating download links with fresh status values:', freshStatusValues);
            
            Object.entries(window.files).forEach(([itemId, fileSet]) => {
                const txtBtn = document.getElementById(`txt-${itemId}`);
                const excelBtn = document.getElementById(`excel-${itemId}`);
                
                if (txtBtn) {
                    const originalUrl = txtBtn.getAttribute('href').split('?')[0]; // Remove existing query params
                    const newUrl = `${originalUrl}?status=${statusParam}&filename=test_${itemId}.txt&t=${Date.now()}`;
                    txtBtn.setAttribute('href', newUrl);
                    console.log(`Updated TXT link to: ${newUrl}`);
                }
                
                if (excelBtn) {
                    const originalUrl = excelBtn.getAttribute('href').split('?')[0]; // Remove existing query params
                    const newUrl = `${originalUrl}?status=${statusParam}&filename=test_${itemId}.xlsx&t=${Date.now()}`;
                    excelBtn.setAttribute('href', newUrl);
                    console.log(`Updated Excel link to: ${newUrl}`);
                }
            });
        }

        async function copyTestCaseTable(itemId) {
            const container = document.getElementById(`testCaseTable${itemId}`);
            if (!container) {
                alert('Error: Could not find test case container');
                return;
            }

            // Force collection of the latest status values directly from the DOM
            const currentStatusValues = collectStatusValues();
            console.log('Status values for copy table:', currentStatusValues);

            // If test cases haven't been loaded yet, load them
            if (!window.testCases || !window.testCases[itemId]) {
                try {
                    // Fetch test cases data
                    const response = await fetch(`/api/content/${window.files[itemId].excel}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error ${response.status}`);
                    }

                    const data = await response.json();
                    if (!window.testCases) window.testCases = {};
                    window.testCases[itemId] = data.content;
                } catch (error) {
                    console.error('Error loading test cases:', error);
                    alert('Failed to load test cases for copying. Please try again.');
                    return;
                }
            }

            // Get the original test data
            const testData = window.testCases[itemId];
            if (!testData || !Array.isArray(testData) || testData.length === 0) {
                alert('No valid test case data found');
                return;
            }

            // Create a dual format for compatibility with both Excel and email
            const desiredOrder = ['Title', 'Scenario', 'Steps', 'Expected Result', 'Status'];
            
            // Create an HTML table for better email/message display
            let htmlTable = '<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse; font-family: Arial, sans-serif; font-size: 14px;">\n';
            
            // Add header row
            htmlTable += '<tr style="background-color: #f2f2f2; font-weight: bold;">';
            desiredOrder.forEach(header => {
                htmlTable += `<th style="border: 1px solid #ddd; padding: 8px; text-align: left;">${header}</th>`;
            });
            htmlTable += '</tr>\n';
            
            // Add data rows
            testData.forEach((testCase, index) => {
                // Apply alternating row colors for better readability
                const rowStyle = index % 2 === 0 ? 'background-color: #ffffff;' : 'background-color: #f9f9f9;';
                htmlTable += `<tr style="${rowStyle}">`;
                
                desiredOrder.forEach(header => {
                    let value = '';
                    
                    if (header === 'Status') {
                        // Get current status from DOM values directly
                        const testCaseId = testCase['Title'] || '';
                        value = currentStatusValues[testCaseId] || testCase['Status'] || '';
                    } else if (header === 'Title') {
                        value = testCase['Title'] || '';
                    } else if (header === 'Steps') {
                        // Format steps with proper numbering
                        let stepsValue = testCase['Steps'] || testCase['Test Steps'] || testCase['steps'] || '';
                        
                        if (Array.isArray(stepsValue)) {
                            value = stepsValue.map((step, idx) => `${idx + 1}. ${step}`).join('<br>');
                        } else {
                            value = String(stepsValue || 'Not provided');
                        }
                    } else {
                        value = testCase[header] || 'Not provided';
                    }
                    
                    // Clean and format the value for HTML
                    if (typeof value === 'object' && !Array.isArray(value)) {
                        try {
                            value = JSON.stringify(value);
                        } catch (e) {
                            value = 'Complex value';
                        }
                    }
                    
                    // Preserve line breaks in HTML but clean up other special characters
                    const formattedValue = String(value)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/\n/g, '<br>');
                        
                    htmlTable += `<td style="border: 1px solid #ddd; padding: 8px; text-align: left;">${formattedValue}</td>`;
                });
                
                htmlTable += '</tr>\n';
            });
            
            htmlTable += '</table>';
            
            // Also create a plain-text tab-delimited version for Excel pasting
            let plainText = desiredOrder.join('\t') + '\n';
            
            testData.forEach(testCase => {
                const row = desiredOrder.map(header => {
                    if (header === 'Status') {
                        const testCaseId = testCase['Title'] || '';
                        return currentStatusValues[testCaseId] || testCase['Status'] || '';
                    } else if (header === 'Title') {
                        return testCase['Title'] || '';
                    } else if (header === 'Steps') {
                        let steps = testCase['Steps'] || testCase['Test Steps'] || testCase['steps'] || '';
                        if (Array.isArray(steps)) {
                            return steps.map((step, idx) => `${idx + 1}. ${step}`).join(' ');
                        }
                        return steps;
                    } else {
                        return testCase[header] || '';
                    }
                });
                
                plainText += row.map(cell => String(cell).replace(/\t/g, ' ').replace(/\n/g, ' ')).join('\t') + '\n';
            });

            try {
                // We're using the ClipboardItem API to set both HTML and text formats
                if (navigator.clipboard.write && ClipboardItem) {
                    const clipboardContent = new ClipboardItem({
                        'text/html': new Blob([htmlTable], {type: 'text/html'}),
                        'text/plain': new Blob([plainText], {type: 'text/plain'})
                    });
                    
                    await navigator.clipboard.write([clipboardContent]);
                } else {
                    // Fallback to setting just text if the ClipboardItem API is not available
                    await navigator.clipboard.writeText(plainText);
                }

                // Show feedback on the correct button
                const copyBtn = document.getElementById(`copy-table-${itemId}`);
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                copyBtn.classList.remove('btn-warning');
                copyBtn.classList.add('btn-success');

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.classList.remove('btn-success');
                    copyBtn.classList.add('btn-warning');
                }, 2000);
            } catch (err) {
                console.error('Clipboard error:', err);
                alert('Failed to copy test cases: ' + err.message);
            }
        }

        async function copyTestCaseUrl(itemId) {
            try {
                // Get the latest status values
                const currentStatusValues = collectStatusValues();
                console.log('Status values for copy URL:', currentStatusValues);
                
                // Make sure test cases are loaded first
                if (!window.testCases || !window.testCases[itemId]) {
                    // Show loading indicator
                    const copyBtn = document.getElementById(`copy-${itemId}`);
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = 'Loading...';
                    copyBtn.disabled = true;

                    try {
                        // Fetch test cases data
                        const response = await fetch(`/api/content/${window.files[itemId].excel}`);
                        if (!response.ok) {
                            throw new Error(`HTTP error ${response.status}`);
                        }

                        const data = await response.json();
                        if (!window.testCases) window.testCases = {};
                        window.testCases[itemId] = data.content;
                    } finally {
                        // Restore button state
                        copyBtn.textContent = originalText;
                        copyBtn.disabled = false;
                    }
                }

                // Update status values in the test cases
                const testCasesWithStatus = window.testCases[itemId].map(tc => {
                    const title = tc['Title'] || '';
                    if (title && currentStatusValues[title]) {
                        return {...tc, Status: currentStatusValues[title]};
                    }
                    return tc;
                });

                const response = await fetch('/api/share', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        test_data: testCasesWithStatus,
                        item_id: itemId,
                        status_values: currentStatusValues
                    })
                });

                const data = await response.json();
                if (data.success) {
                    await navigator.clipboard.writeText(data.share_url);

                    // Show feedback
                    const copyBtn = document.getElementById(`copy-${itemId}`);
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = 'URL Copied!';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                    }, 2000);
                } else {
                    alert('Failed to generate URL: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error generating URL:', error);
                alert('Error generating URL: ' + error.message);
            }
        }

        async function shareTestCase(itemId) {
            try {
                // Get the latest status values
                const currentStatusValues = collectStatusValues();
                console.log('Status values for share URL:', currentStatusValues);
                
                // Make sure test cases are loaded first
                if (!window.testCases || !window.testCases[itemId]) {
                    // Show loading indicator
                    const shareBtn = document.getElementById(`share-${itemId}`);
                    const originalText = shareBtn.textContent;
                    shareBtn.textContent = 'Loading...';
                    shareBtn.disabled = true;

                    try {
                        // Fetch test cases data
                        const response = await fetch(`/api/content/${window.files[itemId].excel}`);
                        if (!response.ok) {
                            throw new Error(`HTTP error ${response.status}`);
                        }

                        const data = await response.json();
                        if (!window.testCases) window.testCases = {};
                        window.testCases[itemId] = data.content;
                    } finally {
                        // Restore button state
                        shareBtn.textContent = originalText;
                        shareBtn.disabled = false;
                    }
                }

                // Update status values in the test cases
                const testCasesWithStatus = window.testCases[itemId].map(tc => {
                    const title = tc['Title'] || '';
                    if (title && currentStatusValues[title]) {
                        return {...tc, Status: currentStatusValues[title]};
                    }
                    return tc;
                });

                const response = await fetch('/api/share', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        test_data: testCasesWithStatus,
                        item_id: itemId,
                        status_values: currentStatusValues
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Open share dialog if supported
                    if (navigator.share) {
                        await navigator.share({
                            title: 'Test Cases',
                            text: `Test Cases for ${itemId}`,
                            url: data.share_url
                        });
                    } else {
                        // Fallback to copying to clipboard
                        await navigator.clipboard.writeText(data.share_url);

                        // Show feedback
                        const shareBtn = document.getElementById(`share-${itemId}`);
                        const originalText = shareBtn.textContent;
                        shareBtn.textContent = 'URL Copied!';
                        setTimeout(() => {
                            shareBtn.textContent = originalText;
                        }, 2000);
                    }
                } else {
                    alert('Failed to generate share URL: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error sharing test case:', error);
                alert('Error sharing test case: ' + error.message);
            }
        }

        // Add polling for status updates
        function setupStatusPolling() {
            console.log('Setting up status polling');
            
            // Immediately poll once on page load
            pollForStatusUpdates();
            
            // Then poll for status updates every 5 seconds (more frequent than before)
            const pollInterval = setInterval(pollForStatusUpdates, 5000);
            
            // Store the interval ID so it can be cleared if needed
            window.statusPollInterval = pollInterval;
        }

        // Separate function to poll for status updates that can be called immediately
        async function pollForStatusUpdates() {
            if (!window.testCaseUrlKey) {
                console.log('No URL key available, skipping status poll');
                return;
            }
            
            try {
                console.log('Polling for status updates...');
                
                // Add cache-busting parameter to prevent caching
                const timestamp = new Date().getTime();
                const response = await fetch(`/api/shared-status?key=${window.testCaseUrlKey}&t=${timestamp}`);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.status_values && Object.keys(data.status_values).length > 0) {
                        console.log('Received updated status values:', data.status_values);
                        
                        // Apply status updates and get whether any changes were made
                        const updatesApplied = applyStatusValuesFromServer(data.status_values);
                        
                        // Also update localStorage with these values
                        mergeWithLocalStorage(data.status_values);
                        
                        // Update download links if any values were updated
                        if (updatesApplied) {
                            console.log('Status values were updated, refreshing download links');
                            updateDownloadLinks();
                        }
                    } else {
                        console.log('No status values received from server');
                    }
                } else {
                    console.error('Error response from status API:', response.status);
                }
            } catch (error) {
                console.error('Error polling for status updates:', error);
            }
        }

        // Apply status values fetched from server, only updating if values are different
        function applyStatusValuesFromServer(statusValues) {
            const statusSelects = document.querySelectorAll('.status-select');
            let updatesApplied = false;
            
            statusSelects.forEach(select => {
                const testCaseId = select.getAttribute('data-test-case-id');
                if (testCaseId && statusValues[testCaseId] && select.value !== statusValues[testCaseId]) {
                    console.log(`Updating status for ${testCaseId} to ${statusValues[testCaseId]} (was: ${select.value})`);
                    select.value = statusValues[testCaseId];
                    select.setAttribute('data-original-value', statusValues[testCaseId]);
                    updatesApplied = true;
                }
            });
            
            if (updatesApplied) {
                console.log('Status updates were applied from server');
            }
            
            return updatesApplied;
        }

        // Merge server status values with localStorage
        function mergeWithLocalStorage(statusValues) {
            try {
                const urlKey = window.testCaseUrlKey;
                if (!urlKey) return;
                
                const storageKey = `status_values_${urlKey}`;
                const savedStr = localStorage.getItem(storageKey);
                let savedValues = savedStr ? JSON.parse(savedStr) : {};
                
                // Merge with new values (server values take precedence)
                const mergedValues = {...savedValues, ...statusValues};
                
                // Save back to localStorage
                localStorage.setItem(storageKey, JSON.stringify(mergedValues));
                console.log('Updated localStorage with merged status values');
            } catch (e) {
                console.error('Error merging status with localStorage:', e);
            }
        }

        // The implementation of updateTestCaseStatus with immediate download link update
        async function updateTestCaseStatus(testCaseId, status, event) {
            const select = event.target;
            const originalValue = select.getAttribute('data-original-value') || '';

            // Skip update if status is empty
            if (!status) {
                console.log('Empty status selected, skipping update');
                return;
            }

            try {
                // Use the stored URL key
                const urlKey = window.testCaseUrlKey;

                console.log('Update Status Request - Identifier:', testCaseId);
                console.log('Update Status Request - Status:', status);
                console.log('Update Status Request - URL Key:', urlKey);

                // Get the test case ID from the data attribute if not provided or undefined
                if (!testCaseId || testCaseId === "undefined") {
                    testCaseId = select.getAttribute('data-test-case-id');
                    console.log('Using test case ID from data attribute:', testCaseId);
                }

                if (!testCaseId || testCaseId === "undefined" || testCaseId === 'N/A') {
                    console.error('Test Case identifier is undefined or empty');
                    throw new Error('Test Case identifier is missing or invalid. Cannot update status.');
                }

                if (!urlKey) {
                    console.error('URL Key is undefined or empty');
                    throw new Error('URL key is missing. Please reload the page with a valid URL.');
                }

                select.disabled = true;

                // Format the request data to match backend expectations
                const requestData = {
                    test_case_id: testCaseId, // Using the title as the identifier
                    status: status,
                    key: urlKey
                };

                console.log('Sending request data:', JSON.stringify(requestData));

                const response = await fetch('/api/update-status', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                console.log('Response status:', response.status);
                console.log('Response status text:', response.statusText);

                if (!response.ok) {
                    let errorMessage = 'Failed to update status';
                    try {
                        const errorData = await response.json();
                        console.error('Error response data:', errorData);
                        errorMessage = errorData.message || errorData.error || errorMessage;
                    } catch (jsonError) {
                        console.error('Error parsing error response:', jsonError);
                        // Try to get response text if JSON parsing fails
                        try {
                            const textResponse = await response.text();
                            console.error('Error response text:', textResponse);
                        } catch (textError) {
                            console.error('Could not get response text:', textError);
                        }
                    }
                    throw new Error(errorMessage);
                }

                // Update was successful
                select.setAttribute('data-original-value', status);
                
                // Save to localStorage
                saveStatusesToLocalStorage();
                
                // Force a sync with MongoDB to ensure all status values are up to date
                try {
                    await fetch(`/api/debug/force-sync?key=${urlKey}&t=${Date.now()}`);
                    console.log('Force-synced status values with MongoDB');
                } catch (syncError) {
                    console.warn('Failed to force-sync with MongoDB:', syncError);
                }
                
                // Immediately update download links with the new status
                // Get all the current status values directly from the DOM
                const freshStatusValues = {};
                const statusSelects = document.querySelectorAll('.status-select');
                statusSelects.forEach(s => {
                    const id = s.getAttribute('data-test-case-id');
                    const val = s.value;
                    if (id && val) {
                        freshStatusValues[id] = val;
                    }
                });
                
                // Update download links with fresh status values
                const statusParam = encodeURIComponent(JSON.stringify(freshStatusValues));
                
                // Update all download links with the latest values
                Object.entries(window.files).forEach(([itemId, fileSet]) => {
                    const txtBtn = document.getElementById(`txt-${itemId}`);
                    const excelBtn = document.getElementById(`excel-${itemId}`);
                    
                    if (txtBtn) {
                        const originalUrl = txtBtn.getAttribute('href').split('?')[0];
                        const newUrl = `${originalUrl}?status=${statusParam}&filename=test_${itemId}.txt&t=${Date.now()}`;
                        txtBtn.setAttribute('href', newUrl);
                        console.log(`Updated TXT link with fresh status values`);
                    }
                    
                    if (excelBtn) {
                        const originalUrl = excelBtn.getAttribute('href').split('?')[0];
                        const newUrl = `${originalUrl}?status=${statusParam}&filename=test_${itemId}.xlsx&t=${Date.now()}`;
                        excelBtn.setAttribute('href', newUrl);
                        console.log(`Updated Excel link with fresh status values`);
                    }
                });

                // Show success message
                const successMessage = document.createElement('div');
                successMessage.className = 'alert alert-success position-fixed top-0 start-50 translate-middle-x mt-3';
                successMessage.style.zIndex = '1000';
                successMessage.textContent = 'Status updated successfully';
                document.body.appendChild(successMessage);

                setTimeout(() => successMessage.remove(), 3000);

            } catch (error) {
                console.error('Error updating status:', error);
                alert(error.message || 'Failed to update status. Please try again.');
                select.value = originalValue; // Revert to original value
            } finally {
                select.disabled = false;
            }
        }

        // Add event listener to update download links immediately when status changes
        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('status-select')) {
                e.target.setAttribute('data-previous-value', e.target.value);
                const testCaseId = e.target.getAttribute('data-test-case-id');
                console.log('Status changed for test case ID:', testCaseId);
                console.log('New status:', e.target.value);
                
                // Save to localStorage immediately on change
                saveStatusesToLocalStorage();
                
                // Update download links IMMEDIATELY when status changes
                updateDownloadLinks();
                
                // Call the update function to send to server
                updateTestCaseStatus(testCaseId, e.target.value, e);
            }
        });

        // Ensure status values are reapplied when table is opened
        document.addEventListener('click', function(e) {
            // If clicking on accordion header to expand
            if (e.target && e.target.classList.contains('accordion-button')) {
                setTimeout(() => {
                    applyStatusValues();
                    updateDownloadLinks();
                }, 200);
            }
        });
    </script>
</body>

</html>